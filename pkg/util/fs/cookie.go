package fs

import (
	"bufio"
	"bytes"
	"errors"
	"net/http"
	"strconv"
	"strings"
	"time"
)

var (
	cookieComment  = []byte("#")
	cookieSplitter = []byte("\t")
	cookieTrue     = []byte("TRUE")
	cookieFalse    = []byte("FALSE")
	cookieDot      = []byte(".")
)

func ParseNetscapeCookie(data []byte) (ret []*http.Cookie) {
	r := bufio.NewScanner(bytes.NewReader(data))
	for r.Scan() {
		line := r.Bytes()
		if bytes.HasPrefix(line, cookieComment) || len(line) == 0 {
			continue
		}
		split := bytes.Split(line, cookieSplitter)
		if len(split) != 7 {
			continue
		}

		var expireTime time.Time
		// try paring unix timestamp
		expires := bytes.Split(split[4], cookieDot)
		expireUnixNano := int64(0)
		expireUnix, expErr := strconv.ParseInt(string(expires[0]), 10, 64)
		if expErr != nil {
			goto timeParse
		}
		if len(expires) > 1 {
			expireUnixNano, expErr = strconv.ParseInt(string(expires[1]), 10, 64)
			if expErr != nil {
				goto timeParse
			}
		}
		expireTime = time.Unix(expireUnix, expireUnixNano)
		goto timeParseOK
	timeParse:
		// fallback to parse as RFC850
		expireTime, expErr = time.Parse(time.RFC850, string(split[4]))
		if expErr != nil {
			continue
		}
	timeParseOK:
		// all ok
		cookie := &http.Cookie{
			Name:     string(split[5]),
			Value:    string(split[6]),
			Path:     string(split[2]),
			Domain:   string(split[0]),
			Expires:  expireTime,
			Secure:   bytes.Equal(bytes.ToUpper(split[3]), cookieTrue),
			HttpOnly: bytes.Equal(bytes.ToUpper(split[1]), cookieTrue),
		}

		ret = append(ret, cookie)
	}

	return
}

const cookieHeader = `# Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This file was generated by fs.cookie
`

var (
	ErrEmptyCookieName = errors.New("empty cookie name")
)

func ToNetscapeCookie(ck []*http.Cookie) ([]byte, error) {
	buf := new(bytes.Buffer)
	_, err := buf.WriteString(cookieHeader)
	if err != nil {
		return nil, err
	}
	for _, c := range ck {
		if len(c.Name) == 0 {
			return nil, ErrEmptyCookieName
		}
		var line []string
		line = append(line, c.Domain)
		line = append(line, cookieBool(c.HttpOnly))
		line = append(line, c.Path)
		line = append(line, cookieBool(c.Secure))
		line = append(line, strconv.FormatInt(c.Expires.Unix(), 10))
		line = append(line, c.Name)
		line = append(line, c.Value)
		_, err = buf.WriteString(strings.Join(line, string(cookieSplitter)))
		if err != nil {
			return nil, err
		}
		buf.Write([]byte("\n"))
	}
	return buf.Bytes(), nil
}

func cookieBool(b bool) string {
	if b {
		return string(cookieTrue)
	}
	return string(cookieFalse)
}
